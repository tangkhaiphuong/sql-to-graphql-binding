<#@ template language="C#" hostspecific="True" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Globalization" #>
<#@ include file="..\..\Configure.tt" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated.
// 
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Dynamic.Core;
using System.Reflection;
using System.Threading.Tasks;
using Contoso.Unicorn.Entities;
using Contoso.Unicorn.GraphQL.Types;
using Fluid;
using GraphQL;
using GraphQL.Builders;
using GraphQL.Relay.Types;
using Microsoft.Extensions.DependencyInjection;
using GraphQL.Language.AST;
using GraphQL.Types.Relay.DataObjects;
using Contoso.Unicorn.GraphQL.Proxies;
using System.Collections.Concurrent;
using Microsoft.EntityFrameworkCore;
using Z.EntityFramework.Plus;
using Contoso.EFCore;

namespace Contoso.Unicorn.GraphQL.Queries
{
    /// <inheritdoc />
    public partial class UnicornQuery
    {<#
    var tables = GetUnicornDefinitions().ToList();

    foreach(var table in tables) 
    {
        var tableName = table.First()["TableName"].ToString();
        var schemaName = table.First()["SchemaName"].ToString();

        var relationships = GetRelationships(Path.Combine(this.Host.ResolvePath(string.Empty) , @"..\..\Relationship.xml"));

        var links = relationships.Where(c => c.Start.Name == tableName).Select(c => c.End.Name).Concat(
            relationships.Where(c => c.End.Name == tableName).Select(c => c.Start.Name)).Distinct()
            .ToList();


        var prefixEntity = schemaName == "dbo" ? "": "Entities." + ToPascal(schemaName) + ".";
        var prefixProxy = schemaName == "dbo" ? "" : "Proxies." + ToPascal(schemaName) + ".";
        var prefixNamespace = schemaName == "dbo" ? "" : ToPascal(schemaName) + ".";
        var prefixType = schemaName == "dbo" ? "" : "Types." + ToPascal(schemaName) + ".";
#>

        /// <summary>
        /// Resolve <#= ToHuman(tableName).ToLower() #>.
        /// </summary>
        /// <param name="resolveConnectionContext">GraphQL context.</param>
        /// <returns></returns>
        private static async Task<object> Resolve<#= ToPlural(tableName) #>Async(IResolveConnectionContext<object> resolveConnectionContext)
        {
            if (resolveConnectionContext == null) throw new ArgumentNullException(nameof(resolveConnectionContext));

            if (resolveConnectionContext.First < 0) throw new ArgumentOutOfRangeException(nameof(resolveConnectionContext), "context.First is less than 0.");

            if (resolveConnectionContext.Last != null) throw new NotSupportedException("Not support last.");

            if (resolveConnectionContext.Before != null) throw new NotSupportedException("Not support before cursor.");

            var serviceProvider = resolveConnectionContext.UserContext[nameof(ServiceProvider)] as IServiceProvider;

            using var scope = serviceProvider.CreateScope();

            await using var unicornContext = scope.ServiceProvider.GetService<UnicornContext>();

            await using var transaction = await unicornContext.Database.BeginTransactionAsync(System.Data.IsolationLevel.ReadUncommitted, resolveConnectionContext.CancellationToken).ConfigureAwait(false);

            var isEnabledLiquid = (bool)resolveConnectionContext.UserContext["template"];
            var take = (int)resolveConnectionContext.UserContext["paging"];
            var @global = resolveConnectionContext.UserContext["global"] as ConcurrentDictionary<string, object>;
            var predicate = resolveConnectionContext.GetArgument<string>("predicate")?.Trim();
            var ordering = resolveConnectionContext.GetArgument<string>("ordering")?.Trim();
            var args = resolveConnectionContext.GetArgument<object[]>("args");
            var force = (bool)resolveConnectionContext.UserContext["force"];
            var multiple = resolveConnectionContext.GetArgument<bool>("multiple");
            var unique = resolveConnectionContext.GetArgument<bool>("unique");
<#
            if (links.Count > 0)
            {
#>
            var links = (IDictionary<string, object>)resolveConnectionContext.GetArgument<object>("link", new Dictionary<string, object>()) ?? new Dictionary<string, object>();
<#
            }
#>

            var templateOptions = serviceProvider.GetService<TemplateOptions>();
            var fluidParser = new FluidParser();
            fluidParser.RegisterExpressionTag("stop", UnicornSchema.HandleStopTag);

            var entityType = typeof(<#= prefixEntity + tableName #>Entity);

            var columns = new HashSet<PropertyInfo>();

            if (resolveConnectionContext.SubFields.TryGetValue("items", out var items))
                foreach (var field in items
                    .SelectionSet
                    .Children
                    .OfType<Field>()
                    .SelectMany(_ => <#= prefixType + tableName #>Type.DependentFields.TryGetValue(_.Name, out var column) ? column : Enumerable.Empty<string>())
                    .Select(entityType.GetProperty)
                    .Where(_ => _ != null))
                    columns.Add(field);

            columns.Add(entityType.GetProperty(nameof(BaseEntity.Id)));

            var columnList = "new (" + string.Join(", ", columns.Select(_ => _.Name).ToArray()) + ")";

            var hasPreviousPage = false;
            var offset = 0;
            var totalCount = -1;
            var @break = false;
            var loop = 0;
            var entityTypes = new HashSet<Type>();
            entityTypes.Add(entityType);

            var queryables = new LinkedList<QueryFutureEnumerable>();

            do
            {
                var queryable = unicornContext.<#= prefixNamespace + ToPlural(tableName) #>.AsQueryable();

<#
            if (links.Count > 0)
            {
#>
                foreach (var link in links)
                {<#
            }

            foreach (var link in links)
            {
                var node = relationships.FirstOrDefault(c =>
                    c.Start.Name == link && c.End.Name == tableName ||
                    c.End.Name == link && c.Start.Name == tableName);

                if (node == null) continue;

            var prefixStartEntity = node.Start.Schema == "dbo" ? "": "Entities." + ToPascal(node.Start.Schema) + ".";
            var prefixStartProxy = node.Start.Schema == "dbo" ? "" : "Proxies." + ToPascal(node.Start.Schema) + ".";
            var prefixStartNamespace = node.Start.Schema == "dbo" ? "" : ToPascal(node.Start.Schema) + ".";
            var prefixStartType = node.Start.Schema == "dbo" ? "" : "Types." + ToPascal(node.Start.Schema) + ".";
            var prefixEndEntity = node.End.Schema == "dbo" ? "": "Entities." + ToPascal(node.End.Schema) + ".";
            var prefixEndProxy = node.End.Schema == "dbo" ? "" : "Proxies." + ToPascal(node.End.Schema) + ".";
            var prefixEndNamespace = node.End.Schema == "dbo" ? "" : ToPascal(node.End.Schema) + ".";
            var prefixEndType = node.End.Schema == "dbo" ? "" : "Types." + ToPascal(node.End.Schema) + ".";

                var isSwap = node.Start.Name == tableName;
#>

                    if (link.Key == "<#= ToCamel(link) #>" && link.Value is IDictionary<string, object> <#= ToCamel(link) #>QueryLink)
                    {

<#
                do {
                    var nodes = new List<Tuple<Node, Node>>();

                    nodes.Add(isSwap ? Tuple.Create(node.Start, node.Start) : Tuple.Create(node.End, node.End));

                    nodes.AddRange(isSwap ? node.Routes : node.Routes.Select(c => Tuple.Create(c.Item2, c.Item1)).Reverse());

                    nodes.Add(isSwap ? Tuple.Create(node.End, node.End) : Tuple.Create(node.Start, node.Start));

                    for (var index = 1; index < nodes.Count; ++index)
                    {
#>
                        entityTypes.Add(unicornContext.<#= (nodes[index].Item1.Schema == "dbo" ? "" : ToPascal(nodes[index].Item1.Schema) + ".") + ToPlural(nodes[index].Item1.Name) #>.EntityType.ClrType);
<#
                    }
                } while(false);
#>

                        switch (<#= ToCamel(link) #>QueryLink["all"])
                        {
<#
                foreach (var type in new[] {"false", "true"})
                {
#>
                            case <#= type #>:
                                {
<#
                    var nodes = new List<Tuple<Node, Node>>();

                    nodes.Add(isSwap ? Tuple.Create(node.Start, node.Start) : Tuple.Create(node.End, node.End));

                    nodes.AddRange(isSwap ? node.Routes : node.Routes.Select(c => Tuple.Create(c.Item2, c.Item1)).Reverse());

                    nodes.Add(isSwap ? Tuple.Create(node.End, node.End) : Tuple.Create(node.Start, node.Start));

#>
                                    var queryableLink = queryable
<#
                            for (var index = 1; index < nodes.Count; ++index)
                            {
#>
                                        .<#= type == "false" ? "Join": "GroupJoin" #>(
                                            unicornContext.<#= (nodes[index].Item1.Schema == "dbo" ? "" : ToPascal(nodes[index].Item1.Schema) + ".") + ToPlural(nodes[index].Item1.Name) #>,
                                            @this => @this<#= index == 1 ? "" : "." + ToCamel(nodes[index - 1].Item2.Name) #>.<#= nodes[index - 1].Item2.Key #>,
                                            that => that.<#= nodes[index].Item1.Key #>,
                                            (@this, that) => new
                                            {
                                                @this<#= index == 1 ? "" : ".@this"  #>,
<#
                                for (var index2 = 2; index2 <= index; ++index2)
                                {
#>
                                                @this.<#= ToCamel(nodes[index2 - 1].Item1.Name) #>,
<#
                                }
#>
                                                <#= ToCamel(nodes[index].Item1.Name) #> = that
                                        })
<#                              if (type != "false")
                                {
#>
                                        .SelectMany(
                                            that => that.<#= ToCamel(nodes[index].Item1.Name) #>.DefaultIfEmpty(),
                                            (@this, that) => new
                                            {
                                                @this<#= index == 1 ? "" : ".@this"  #>,
<#
                                for (var index2 = 2; index2 <= index; ++index2)
                                {
#>
                                                @this.<#= ToCamel(nodes[index2 - 1].Item1.Name) #>,
<#
                                }
#>
                                                <#= ToCamel(nodes[index].Item1.Name) #> = that
                                            })
<#
                                }
                            }
#>
                                        .Select(_ => _);

                                    if (<#= ToCamel(link) #>QueryLink.TryGetValue("predicate", out var predicateObj) &&
                                        predicateObj is string predicateLink && !string.IsNullOrEmpty(predicateLink))
                                    {
                                        var templateContext = new TemplateContext(templateOptions);
                                        templateContext.SetValue("global", @global);
                                        templateContext.SetValue("args", args);
                                        templateContext.SetValue("loop", new Dictionary<string, object>{{"index", loop}});
                                        templateContext.SetValue("stop", false);

                                        if (isEnabledLiquid)
                                        {
                                            predicateLink = await fluidParser.Parse(predicateLink).RenderAsync(templateContext).ConfigureAwait(false);
                                            predicateLink = predicateLink?.Trim();
                                        }

                                        if (!string.IsNullOrEmpty(predicateLink))
                                        {
                                            if (<#= ToCamel(link) #>QueryLink.TryGetValue("args", out var argsObj) &&
                                                argsObj is IEnumerable<object> argsLink)
                                                queryableLink = queryableLink.Where(predicateLink, argsLink.ToArray());
                                            else
                                                queryableLink = queryableLink.Where(predicateLink);
                                        }

                                        @break = templateContext.GetValue("stop").ToBooleanValue();
                                    }

                                    queryable = queryableLink.Select(_ => _<#= type == "false" ? "": ".@this" #>.@this);

                                    break;
                                }
<#
                }
#>
                            default:
                                throw new ArgumentOutOfRangeException();
                        }
                        continue;
                    }
<#
            }
            if (links.Count > 0)
            {
#>
                }
<#
            }
#>
                if (!force) queryable = queryable.Where(_ => _.DeletedDate == null);

                var predicateNew = string.Empty;

                if (!string.IsNullOrEmpty(predicate))
                {
                    var templateContext = new TemplateContext(templateOptions);
                    templateContext.SetValue("global", @global);
                    templateContext.SetValue("args", args);
                    templateContext.SetValue("loop", new Dictionary<string, object>{ { "index", loop } });
                    templateContext.SetValue("stop", false);

                    if (isEnabledLiquid)
                    {
                        predicateNew = await fluidParser.Parse(predicate).RenderAsync(templateContext).ConfigureAwait(false);
                        predicateNew = predicateNew?.Trim();
                    }

                    if (!string.IsNullOrEmpty(predicateNew))
                    {
                        if (args == null)
                            queryable = queryable.Where(predicateNew);
                        else
                            queryable = queryable.Where(predicateNew, args);
                    }

                    @break = templateContext.GetValue("stop").ToBooleanValue();
                }

                if (unique && multiple == false) queryable = queryable.Distinct();

                if (!string.IsNullOrEmpty(ordering))
                    queryable = queryable.OrderBy(ordering);

                if (!string.IsNullOrEmpty(resolveConnectionContext.After) && multiple == false)
                {
                    offset = ConnectionUtils.CursorToOffset(resolveConnectionContext.After) + 1;
                    hasPreviousPage = offset > 0;
                }

                if (hasPreviousPage && multiple == false) queryable = queryable.Skip(offset);

                if (resolveConnectionContext.First != null && multiple == false)
                    queryable = queryable.Take(resolveConnectionContext.First.Value);
                else if (take > -1 && multiple == false)
                    queryable = queryable.Take(take);

                queryables.AddLast(queryable
                    .WithHint(SqlServerTableHintFlags.NOLOCK, entityTypes.ToArray())
                    .Select(columnList)
                    .FutureObject());

                if (multiple && @break) break;

                ++loop;

                resolveConnectionContext.CancellationToken.ThrowIfCancellationRequested();

            } while (multiple);

            var proxies = new LinkedList<BaseProxy>();

            foreach (var queryable in queryables)
            {
                var results = await queryable
                    .ToListAsync(resolveConnectionContext.CancellationToken).ConfigureAwait(false);
                
                foreach (var item in results.Select(row =>
                    {
                        if (row == null) return null;

                        var result = new <#= prefixEntity + tableName #>Entity();

                        var rowType = row.GetType();

                        foreach (var property in columns)
                            property.SetValue(result, rowType.GetProperty(property.Name)?.GetValue(row));

                        return new <#= prefixProxy + tableName #>Proxy(result);
                    }))
                    proxies.AddLast(item);
            }

            if (multiple)
            {
                IEnumerable<BaseProxy> edgesEnumerable = unique ? proxies.Distinct(EqualityComparer<BaseProxy>.Default) : proxies;

                if (!string.IsNullOrEmpty(resolveConnectionContext.After))
                {
                    offset = ConnectionUtils.CursorToOffset(resolveConnectionContext.After) + 1;
                    hasPreviousPage = offset > 0;
                }

                if (hasPreviousPage && multiple == false) edgesEnumerable = edgesEnumerable.Skip(offset);

                if (resolveConnectionContext.First != null)
                    edgesEnumerable = edgesEnumerable.Take(resolveConnectionContext.First.Value);
                else if (take > -1 && multiple == false)
                    edgesEnumerable = edgesEnumerable.Take(take);

                proxies = new LinkedList<BaseProxy>(edgesEnumerable);
            }

            if (resolveConnectionContext.First == null && take < 0 && totalCount < 0)
                totalCount = proxies.Count + offset;
            else if (resolveConnectionContext.First > proxies.Count)
                totalCount = proxies.Count + offset;

            var edges = proxies.Select((item, i) => new Edge<BaseProxy>
            {
                Node = item,
                Cursor = ConnectionUtils.OffsetToCursor(offset + i)
            }).ToList();

            var result = new Connection<BaseProxy>
            {
                Edges = edges,
                TotalCount = totalCount,
                PageInfo = new PageInfo
                {
                    StartCursor = edges.FirstOrDefault()?.Cursor,
                    EndCursor = edges.LastOrDefault()?.Cursor,
                    HasPreviousPage = hasPreviousPage,
                    HasNextPage = edges.Count == take,
                }
            };

            if (isEnabledLiquid)
            {
<#
                if (schemaName == "dbo")
                {
#>
                @global[resolveConnectionContext.FieldAst.Alias ?? resolveConnectionContext.FieldAst.Name] = result;
<#
                }
                else
                {
#>
                (@global.GetOrAdd(
                    "<#= ToHuman(schemaName).ToLower() #>",
                    new ConcurrentDictionary<string, object>()) as IDictionary<string, object>)
                    [resolveConnectionContext.FieldAst.Alias ?? resolveConnectionContext.FieldAst.Name] = result;
<#
                }
#>
            }

            return result;
        }
<#
        }
#>
    }
}
