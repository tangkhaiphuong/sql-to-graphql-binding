<#@ template language="C#" hostspecific="True" #>
<#@ assembly name="System.Runtime" #>
<#@ assembly name="System.Globalization" #>
<#@ include file="..\..\Configure.tt" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// 
// This source code was auto-generated.
// 
using System;
using System.Linq;
using System.Diagnostics.CodeAnalysis;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using Contoso.Unicorn.GraphQL.Attributes;
using GraphQL.Types;
using Contoso.Unicorn.GraphQL.Proxies;
<#
    var relationships = GetRelationships(Path.Combine(this.Host.ResolvePath(string.Empty) , @"..\..\Relationship.xml"));

    var linkSet = relationships.Select(c => c.Start.Name).Concat(relationships.Select(c => c.End.Name)).Distinct().OrderBy(c => c).ToHashSet();
    foreach(var table in GetUnicornDefinitions()) 
    {
        var tableName = table.Key.TableName;
        var schemaName = table.Key.SchemaName;
        
        var prefixProxies = schemaName == "dbo" ? "" : "Proxies." + ToPascal(schemaName) + ".";
#>

// ReSharper disable once IdentifierTypo
namespace Contoso.Unicorn.GraphQL.Types<#= schemaName == "dbo" ? "" : "." + ToPascal(schemaName)#>
{
    /// <summary>
    /// Definition query type of <#= ToHuman(tableName).ToLower() #>.
    /// </summary>
    [SuppressMessage("ReSharper", "UnusedMember.Global")]
    [SuppressMessage("ReSharper", "MemberHidesStaticFromOuterClass")]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    [SuppressMessage("ReSharper", "PartialTypeWithSinglePart")]
    [SuppressMessage("ReSharper", "AccessToDisposedClosure")]
    [GeneratedCode("TextTemplatingFileGenerator", "1.0.0")]
    public sealed partial class <#= tableName #>Type : BaseProxyType<<#=prefixProxies + tableName #>Proxy>
    {
        /// <summary>
        /// Required fields
        /// </summary>
        public static readonly Dictionary<string, IEnumerable<string>> DependentFields = new Dictionary<string, IEnumerable<string>>(StringComparer.InvariantCultureIgnoreCase)
        {
            { "<#= tableName #>Id", new [] { "<#= tableName #>Id" } },
<#
        foreach (var column in table)
        {
           var columnName = column["ColumnName"].ToString();

           if (columnName.Contains(" ")) continue;

           if (IsSkip(columnName)) continue;
#>
            { "<#= columnName #>", new [] { "<#= columnName #>" } },
<#
        }

        var existedSchema = new HashSet<string>();

        foreach (var item in relationships)
        {
            var isParent = string.Equals(item.Start.Name, tableName, StringComparison.OrdinalIgnoreCase);
            var isChild = string.Equals(item.End.Name, tableName, StringComparison.OrdinalIgnoreCase);

            if (!isParent && !isChild) continue;

            if (isParent)
            {
                var temp = item.End.Schema == "dbo" ? ToPascal(item.End.Name) : ToPascal(item.End.Schema);

                if (existedSchema.Contains(temp)) continue;

                existedSchema.Add(temp);
#>
            { "<#= temp #>", new [] { "<#= item.Start.Key #>" } },
<#
            }
            if (isChild)
            {
                var temp = item.Start.Schema == "dbo" ? ToPascal(item.Start.Name) : ToPascal(item.Start.Schema);

                if (existedSchema.Contains(temp)) continue;

                existedSchema.Add(temp);
#>
            { "<#= temp #>", new [] { "<#= item.End.Key #>" } },
<#                
            }
        }
        
#>
            { "CreatedDate", new [] { "CreatedDate" } },
            { "ModifiedDate", new [] { "ModifiedDate" } },
            { "DeletedDate", new [] { "DeletedDate" } },
            { "State", new [] { "State" } }
        };

        /// <inheritdoc />
        public <#= tableName #>Type() : base("<#= (schemaName == "dbo" ? "" : ToPascal(schemaName) + "_") +  tableName #>")
        {
            Description = "<#= (schemaName == "dbo" ? "" : ToHuman(schemaName) + " ") + ToHuman(tableName).ToLower() #>";
<#
        foreach(var column in table)
        {
            var isNullable = (bool)column["IsNullable"];
            var columnName = column["ColumnName"].ToString();

            if (columnName.Contains(" ")) continue;

            if (IsSkip(columnName)) continue;
#>

            Field(_ => _.<#= columnName #><#=isNullable ? ", true": "" #>).Description("Gets <#= ToHuman(columnName).ToLower() #>.");
<#
        }

        existedSchema = new HashSet<string>();

        foreach(var item in relationships)
        {
            var isParent = string.Equals(item.Start.Name, tableName, StringComparison.OrdinalIgnoreCase);
            var isChild = string.Equals(item.End.Name, tableName, StringComparison.OrdinalIgnoreCase);

            if (!isParent && !isChild) continue;

            if (isParent)
            {
                if (item.End.Schema == "dbo")
                {
#>

            FieldAsync<<#= item.End.Name #>Type>("<#= ToCamel(item.End.Name) #>", resolve: Resolve<#= item.End.Name #>Async, description: "Gets <#=
                            ToHuman(item.End.Name).ToLower() #>.");
<#
                }
            }
            if (isChild)
            {
                if (item.Start.Schema == "dbo")
                {
#>

            Connection<<#= item.Start.Name #>Type>()
                .Name("<#= ToCamel(ToPlural(item.Start.Name)) #>")
                .Description("Query many <#= ToHuman(item.Start.Name).ToLower() #> base on criteria.")
                .Argument<StringGraphType>("predicate", "An expression string to test each element for a condition")
                .Argument<ListGraphType<StringGraphType>>("args", "An object array that contains zero or more objects to insert into the predicate as parameters. Similar to the way String.Format formats strings that contains elements from the input sequence that satisfy the condition specified by predicate.")
                .Argument<BooleanGraphType>("unique", "Returns distinct elements from a sequence.")
                .Argument<<#= tableName #>LinkInputType>("link", "Links with other node base on inner/outer.")
                .Argument<BooleanGraphType>("multiple", "Running predicate many time.")
                .Argument<StringGraphType>("ordering", " Sorts the elements of a sequence in ascending or descending order according to a key.")
                .ResolveAsync(Resolve<#= ToPlural(item.Start.Name) #>Async);
<#
                }
            }
            
            foreach(var schema in new [] { item.Start.Schema, item.End.Schema})
            {
                if (schema == "dbo" || existedSchema.Contains(schema)) continue;

                existedSchema.Add(schema);
#>

            Field<<#= tableName #>_<#= ToPascal(schema) #>Type>()
                .Name("<#= ToHuman(schema) #>").ToLower()
                .Description("Fetches an object given its global Id")
                .Resolve(context => new <#= ToPascal(schema) #>Proxy(context.Source));
<#
            }
            
        }
#>

            var methods = GetType().GetMethods()
                .Where(m => m.GetCustomAttributes(typeof(ConstructorAttribute), false).Length > 0);

            foreach (var item in methods) item.Invoke(this, null);
        }
    }
}
<#
    }

    foreach(var schema in GetUnicornDefinitions().SelectMany(c => c).GroupBy(c => c["SchemaName"]))
    {
        var schemaName = schema.Key.ToString();

        if (schemaName == "dbo") continue;
#>

// ReSharper disable once IdentifierTypo
namespace Contoso.Unicorn.GraphQL.Types
{
    /// <summary>
    /// Definition query type of root query <#= ToHuman(schemaName).ToLower() #>.
    /// </summary>
    [SuppressMessage("ReSharper", "UnusedMember.Global")]
    [SuppressMessage("ReSharper", "MemberHidesStaticFromOuterClass")]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    [SuppressMessage("ReSharper", "PartialTypeWithSinglePart")]
    [SuppressMessage("ReSharper", "AccessToDisposedClosure")]
    [GeneratedCode("TextTemplatingFileGenerator", "1.0.0")]
    public sealed partial class RootQuery<#= ToPascal(schemaName) #>Type : ObjectGraphType<<#= ToPascal(schemaName) #>Proxy>
    {
        /// <inheritdoc />
        public RootQuery<#= ToPascal(schemaName) #>Type()
        {
            Name = "RootQuery<#= ToPascal(schemaName) #>";

            Description = "root query <#=  ToHuman(schemaName).ToLower() #>";
<#
            foreach(var table in schema.GroupBy(c => c["TableName"]))
            {
                var tableName = table.Key.ToString();
#>

            Connection<<#= ToPascal(schemaName) #>.<#= tableName #>Type>()
                .Name("<#= ToCamel(ToPlural(tableName)) #>")
                .Description("Query <#= ToHuman(tableName).ToLower() #> base on criteria.")
                .Argument<StringGraphType>("predicate", "An expression string to test each element for a condition")
                .Argument<ListGraphType<StringGraphType>>("args", "An object array that contains zero or more objects to insert into the predicate as parameters. Similar to the way String.Format formats strings that contains elements from the input sequence that satisfy the condition specified by predicate.")
<#if(linkSet.Contains(tableName)) { #>
                .Argument<<#= ToPascal(schemaName) #>.<#= tableName #>LinkInputType>("link", "Links with other node base on inner/outer.")
                .Argument<BooleanGraphType>("unique", "Returns distinct elements from a sequence.")
<# }#>
                .Argument<StringGraphType>("ordering", "Sorts the elements of a sequence in ascending or descending order according to a key.")
                .ResolveAsync(Resolve<#= ToPlural(tableName) #>Async);
<#
            }
#>

            var methods = GetType().GetMethods()
                .Where(m => m.GetCustomAttributes(typeof(ConstructorAttribute), false).Length > 0);

            foreach (var item in methods) item.Invoke(this, null);
        }
    }
}

// ReSharper disable once IdentifierTypo
namespace Contoso.Unicorn.GraphQL.Types
{
    /// <summary>
    /// Definition query type of root mutation <#= ToHuman(schemaName).ToLower() #>.
    /// </summary>
    [SuppressMessage("ReSharper", "UnusedMember.Global")]
    [SuppressMessage("ReSharper", "MemberHidesStaticFromOuterClass")]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    [SuppressMessage("ReSharper", "PartialTypeWithSinglePart")]
    [SuppressMessage("ReSharper", "AccessToDisposedClosure")]
    [GeneratedCode("TextTemplatingFileGenerator", "1.0.0")]
    public sealed partial class RootMutation<#= ToPascal(schemaName) #>Type : ObjectGraphType<<#= ToPascal(schemaName) #>Proxy>
    {
        /// <inheritdoc />
        public RootMutation<#= ToPascal(schemaName) #>Type()
        {
            Name = "RootMutation<#= ToPascal(schemaName) #>";

            Description = "root mutation <#=  ToHuman(schemaName).ToLower() #>";
<#
            foreach(var table in schema.GroupBy(c => c["TableName"]))
            {
                var tableName = table.Key.ToString();
#>

            Connection<<#= ToPascal(schemaName) #>.<#= tableName #>Type>()
                .Name("<#= ToCamel(ToPlural(tableName)) #>")
                .Description("Mutate <#= ToHuman(tableName) #> base on criteria.").ToLower()
                .Argument<StringGraphType>("predicate", "An expression string to test each element for a condition.")
                .Argument<ListGraphType<StringGraphType>>("args", "List of arguments.")
                .Argument<NonNullGraphType<EnumerationGraphType<MutationAction>>>("action", "Action of mutation.")
                .Argument<<#= ToPascal(schemaName) #>.<#= tableName #>InputType>("node", "Input of single node.")
                .Argument<BooleanGraphType>("ignore", "Ignore action if predicate match.")
                .Argument<BooleanGraphType>("multiple", "Running predicate many time for each node.")
                .Argument<ListGraphType<<#= ToPascal(schemaName) #>.<#= tableName #>InputType>>("nodes", "Input of multi node.")
                .Argument<ListGraphType<NonNullGraphType<StringGraphType>>>("fields", "Field include.")
                .Argument<StringGraphType>("ordering", "Sorts the elements of a sequence in ascending or descending order according to a key.")
                .ResolveAsync(UnicornMutation.ResolveMutation(_ => _.<#= ToPascal(schemaName) #>.<#= ToPlural(tableName) #>, _ => new Proxies.<#= ToPascal(schemaName) #>.<#= tableName #>Proxy(_)));
<#
            }
#>

            var methods = GetType().GetMethods()
                .Where(m => m.GetCustomAttributes(typeof(ConstructorAttribute), false).Length > 0);

            foreach (var item in methods) item.Invoke(this, null);
        }
    }
}
<#
    }

    foreach(var table in GetUnicornDefinitions()) 
    {
        var tableName = table.Key.TableName;

        var existedSchema = new HashSet<string>();

        foreach(var relationship in relationships)
        {
            var isParent = string.Equals(relationship.Start.Name, tableName, StringComparison.OrdinalIgnoreCase);
            var isChild = string.Equals(relationship.End.Name, tableName, StringComparison.OrdinalIgnoreCase);

            if (!isParent && !isChild) continue;

            foreach(var schema in new [] { relationship.Start.Schema, relationship.End.Schema})
            {
                if (schema == "dbo" || existedSchema.Contains(schema)) continue;

                existedSchema.Add(schema);
#>

// ReSharper disable once IdentifierTypo
namespace Contoso.Unicorn.GraphQL.Types
{
    /// <summary>
    /// Definition query type of <#= ToHuman(tableName).ToLower() #>.
    /// </summary>
    [SuppressMessage("ReSharper", "UnusedMember.Global")]
    [SuppressMessage("ReSharper", "MemberHidesStaticFromOuterClass")]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    [SuppressMessage("ReSharper", "PartialTypeWithSinglePart")]
    [SuppressMessage("ReSharper", "AccessToDisposedClosure")]
    [GeneratedCode("TextTemplatingFileGenerator", "1.0.0")]
    public sealed partial class <#= tableName #>_<#= ToPascal(schema) #>Type : ObjectGraphType<<#= ToPascal(schema) #>Proxy>
    {
        /// <inheritdoc />
        public <#= tableName #>_<#= ToPascal(schema) #>Type()
        {
            Name = "<#= ToPascal(tableName) #>_<#= ToPascal(schema) #>";

            Description = "<#= ToHuman(tableName).ToLower() #> <#=  ToHuman(schema).ToLower() #>";
<#
            foreach(var item in relationships)
            {
                isParent = string.Equals(item.Start.Name, tableName, StringComparison.OrdinalIgnoreCase);
                isChild = string.Equals(item.End.Name, tableName, StringComparison.OrdinalIgnoreCase);

                if (!isParent && !isChild) continue;

                if (isParent)
                {
                    if (item.End.Schema == schema)
                    {
#>

            FieldAsync<<#= (item.End.Schema == "dbo" ? "" : ToPascal(item.End.Schema) + "." ) + item.End.Name #>Type>("<#= ToCamel(item.End.Name) #>", resolve: Resolve<#= item.End.Name #>Async, description: "Gets <#=
                            ToHuman(item.End.Name).ToLower() #>.");
<#
                    }
                }
                if (isChild)
                {
                    if (item.Start.Schema == schema)
                    {
#>

            Connection<<#= (item.Start.Schema == "dbo" ? "" : ToPascal(item.Start.Schema) + "." ) + item.Start.Name #>Type>()
                .Name("<#= ToCamel(ToPlural(item.Start.Name)) #>")
                .Description("Query many <#= ToHuman(item.Start.Name).ToLower() #> base on criteria.")
                .Argument<StringGraphType>("predicate", "An expression string to test each element for a condition")
                .Argument<ListGraphType<StringGraphType>>("args", "An object array that contains zero or more objects to insert into the predicate as parameters. Similar to the way String.Format formats strings that contains elements from the input sequence that satisfy the condition specified by predicate.")
<#if(linkSet.Contains(tableName)) {#>
                .Argument<BooleanGraphType>("unique", "Returns distinct elements from a sequence.")
                .Argument<<#= (table.Key.SchemaName == "dbo" ? "" : (ToPascal(table.Key.SchemaName) + ".")) + tableName #>LinkInputType>("link", "Links with other node base on inner/outer.")
<# }#>
                .Argument<StringGraphType>("ordering", " Sorts the elements of a sequence in ascending or descending order according to a key.")
                .ResolveAsync(Resolve<#= ToPlural(item.Start.Name) #>Async);
<#
                    }
                }
            }
#>

            var methods = GetType().GetMethods()
                .Where(m => m.GetCustomAttributes(typeof(ConstructorAttribute), false).Length > 0);

            foreach (var item in methods) item.Invoke(this, null);
        }
    }
}
<#
            }
            
        }
    }
#>